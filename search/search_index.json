{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gopher Guide This is meant to be a quick onramp / cheatsheet for busy people getting into Go. 1. Setup Installation (if necessary): Approach 1: Install directly from go.dev/dl Approach 2 (Preferred, although only for macOS and Linux): Install using Homebrew using brew install go command. Install homebrew if necessary (copy and paste the following in your terminal to install or go to brew.sh for additional instruction) /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" Install Go with brew install go command. Preferred Editors: Now that you have Go, the next step is to setup your editor. I personally like to use NeoVim , but it has a somewhat steep learning curve and can take considerable effort to setup if you are new to it. Goland is a great IDE for Go that I have also used and enjoyed. Unfortunately, this one costs some money, but you can get a free license if you are a university student or faculty. VS Code is another good alternative and is free. I would recommend installing the official Go extension for VS Code as well. 2. The standard main.go Everything in Go is a package. Programs start running in the main package. The first line of any Go file should declare a package name. package main import \"fmt\" func main () { fmt . Println ( \"Gophers are cool\" ) } 3. Imports package main import ( \"fmt\" \"math/rand\" ) // import multiple packages by enclosing with () func main () { fmt . Println ( math . randIntn ( 10 )) //print a random int betwee 0-9 } 4. Data types and variables Go has standard types like: bool string int, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64, uintpr byte (int8) rune (int32, unicode code point) float32, float64 complex64, complex128 package main import \"fmt\" var numGophers int = 0 func main () { // declare and init var with type bool var isGopher bool = false // we can also use a shorthand notation using := isHuman := true // this will infer a type from the initializer fmt . Printf ( \"Value: %v, Type: %T\" , numGophers , numGophers ) fmt . Printf ( \"Value: %v, Type: %T\" , isGopher , isGopher ) fmt . Printf ( \"Value: %v, Type: %T\" , isHuman , isHuman ) } Note We cannot use the shorthand notation with := when declaring variables at the package level. At the package level, everything needs to start with a keyword like var , func , etc. Constants and more package main import ( \"fmt\" \"runtime\" ) func main () { // declare and init a constant variable const pi float64 = 3.14 // declare a var without an initializer var os string // we can now use this later fmt . Println ( pi ) // set operatingSystem variable os = runtime . GOOS fmt . Println ( operatingSystem ) } Type conversions package main import \"fmt\" func main () { i := 77 j := float64 ( i ) // convert i of type int to float64 fmt . Printf ( \"value: %d, type: %T\" , i , i ) // will be an int fmt . Printf ( \"value: %d, type: %T\" , j , j ) // will be float64 } 5. Functions package main import ( \"fmt\" \"strings\" ) // no parameters or return values func sayHello () { fmt . Println ( \"Howdy\" ) } // one parameter and return value func greeting ( name string ) string { return fmt . Sprintf ( \"Howdy %v!\\n\" , name ) } // multiple input parameters and returns func sum ( x , y , z int ) ( int , int ) { return x + y , y + z } // named return func formatName ( name string ) ( formattedName string ) { formattedName := strings . ToUpper ( name ) return } func main () { sayHello () howdyGophers := greeting ( \"gophers\" ) a , b := sum ( 22 , 33 , 44 ) bigGopher := formatName ( \"gopher\" ) } Note In sum(x, y, z int) we only included the int type after the last param. You can use this syntax when params are of the same type. For different types it would look something like func hello(name string, age int)... 6. Looping, Conditionals, Switches, & Defers For package main import \"fmt\" func main () { var z float64 for i := 0 ; i < 10 ; i ++ { z = i * i fmt . Println ( z ) } } In Go, we only have a for loop. For loops are broken down into 3 parts: The init statement which is executed before the first iteration (i.e. i := 0 ) The condition statement which is evaluated before each iteration (i.e. i < 10 ) The post statement which is executed at the end of each iteration (i.e. i++ ) Init and post statements on a loop are optional, i.e. package main import \"fmt\" func main () { i := 0 for i < 10 ; { fmt . Println ( i ) i ++ } } The infinite loop package main import \"fmt\" func main () { i := 0 for { i ++ fmt . Println ( i ) } // run until the end of time (or sooner perhaps) } If package main import \"fmt\" func main () { x := 13 if x > 11 { fmt . Println ( \"x is greater than 11\" ) } else { fmt . Println ( \"x is not greater than 11\" ) } } The short if package main import ( \"fmt\" \"strings\" ) func main () { greeting := \"Howdy gophers!\" if greeting := \"Howdy\" ; strings . Contains ( greeting , \"ow\" ) { fmt . Println ( greeting ) } } Switch package main import ( \"fmt\" \"runtime\" ) func main () { switch os := runtime . GOOS ; os { case \"darwin\" : fmt . Println ( \"Reasonable\" ) case \"linux\" : fmt . Println ( \"The superior OS\" ) default : fmt . Println ( \"I want better for you\" ) } } Tip Switch with no condition is the same as switch true which can be useful for long if-else chains. Defer package main import ( \"fmt\" \"os\" ) func main () { out , _ := os . Create ( \"importantData.txt\" ) defer out . Close () // close file executed after main return out . Write ([] byte ( \"867-5309\" )) } Note Deffered functions are pushed onto a stack and executed in last-in-first-out order. 7. Pointers package main import \"fmt\" func main () { var i * int // pointer j := 11 i = & j // generate pointer to operand fmt . Printf ( \"address, %v\\n\" , i ) fmt . Printf ( \"value, %v\\n\" , * i ) } 8. Structs package main import \"fmt\" type Coordinate struct { X , Y , Z int } func main () { origin := Coordinate { 0 , 0 , 0 } fmt . Println ( origin ) fmt . Printf ( \"x: \\n\" , origin . X ) } 9. Arrays package main import \"fmt\" func main () { a := [ 5 ] int { 0 , 1 , 2 , 3 , 4 } fmt . Println ( a [ 0 ], a [ 1 ]) fmt . Println ( a [ 2 :]) } Note Arrays are of fixed size! 10. Slices package main import \"fmt\" func main () { a := [ 5 ] int { 0 , 1 , 2 , 3 , 4 } var s [] int = a [ 0 : 2 ] fmt . Printf ( \"s: %v, len: %d, cap: %d\\n\" , s , len ( s ), cap ( s )) } Note A slice has a length and capacity. Length is the number of elements it contains, while the capacity is the number of elements in the underlying array. Creating a slice with make package main import \"fmt\" func main () { s := make ([] int , 5 ) // allocate a zeroed array w/ len(s)=10 c := make ([] int , 5 , 10 ) // allocate a zeroed array w/ len(c)=5, cap(c)=10 fmt . Printf ( \"len: %d, cap: %d\\n\" , s , len ( s ), cap ( s )) fmt . Printf ( \"len: %d, cap: %d\\n\" , s , len ( c ), cap ( c )) } Appending to a slice","title":"Gopher Guide"},{"location":"#gopher-guide","text":"This is meant to be a quick onramp / cheatsheet for busy people getting into Go.","title":"Gopher Guide"},{"location":"#1-setup","text":"Installation (if necessary): Approach 1: Install directly from go.dev/dl Approach 2 (Preferred, although only for macOS and Linux): Install using Homebrew using brew install go command. Install homebrew if necessary (copy and paste the following in your terminal to install or go to brew.sh for additional instruction) /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh ) \" Install Go with brew install go command. Preferred Editors: Now that you have Go, the next step is to setup your editor. I personally like to use NeoVim , but it has a somewhat steep learning curve and can take considerable effort to setup if you are new to it. Goland is a great IDE for Go that I have also used and enjoyed. Unfortunately, this one costs some money, but you can get a free license if you are a university student or faculty. VS Code is another good alternative and is free. I would recommend installing the official Go extension for VS Code as well.","title":"1. Setup"},{"location":"#2-the-standard-maingo","text":"Everything in Go is a package. Programs start running in the main package. The first line of any Go file should declare a package name. package main import \"fmt\" func main () { fmt . Println ( \"Gophers are cool\" ) }","title":"2. The standard main.go"},{"location":"#3-imports","text":"package main import ( \"fmt\" \"math/rand\" ) // import multiple packages by enclosing with () func main () { fmt . Println ( math . randIntn ( 10 )) //print a random int betwee 0-9 }","title":"3. Imports"},{"location":"#4-data-types-and-variables","text":"Go has standard types like: bool string int, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64, uintpr byte (int8) rune (int32, unicode code point) float32, float64 complex64, complex128 package main import \"fmt\" var numGophers int = 0 func main () { // declare and init var with type bool var isGopher bool = false // we can also use a shorthand notation using := isHuman := true // this will infer a type from the initializer fmt . Printf ( \"Value: %v, Type: %T\" , numGophers , numGophers ) fmt . Printf ( \"Value: %v, Type: %T\" , isGopher , isGopher ) fmt . Printf ( \"Value: %v, Type: %T\" , isHuman , isHuman ) } Note We cannot use the shorthand notation with := when declaring variables at the package level. At the package level, everything needs to start with a keyword like var , func , etc.","title":"4. Data types and variables"},{"location":"#constants-and-more","text":"package main import ( \"fmt\" \"runtime\" ) func main () { // declare and init a constant variable const pi float64 = 3.14 // declare a var without an initializer var os string // we can now use this later fmt . Println ( pi ) // set operatingSystem variable os = runtime . GOOS fmt . Println ( operatingSystem ) }","title":"Constants and more"},{"location":"#type-conversions","text":"package main import \"fmt\" func main () { i := 77 j := float64 ( i ) // convert i of type int to float64 fmt . Printf ( \"value: %d, type: %T\" , i , i ) // will be an int fmt . Printf ( \"value: %d, type: %T\" , j , j ) // will be float64 }","title":"Type conversions"},{"location":"#5-functions","text":"package main import ( \"fmt\" \"strings\" ) // no parameters or return values func sayHello () { fmt . Println ( \"Howdy\" ) } // one parameter and return value func greeting ( name string ) string { return fmt . Sprintf ( \"Howdy %v!\\n\" , name ) } // multiple input parameters and returns func sum ( x , y , z int ) ( int , int ) { return x + y , y + z } // named return func formatName ( name string ) ( formattedName string ) { formattedName := strings . ToUpper ( name ) return } func main () { sayHello () howdyGophers := greeting ( \"gophers\" ) a , b := sum ( 22 , 33 , 44 ) bigGopher := formatName ( \"gopher\" ) } Note In sum(x, y, z int) we only included the int type after the last param. You can use this syntax when params are of the same type. For different types it would look something like func hello(name string, age int)...","title":"5. Functions"},{"location":"#6-looping-conditionals-switches-defers","text":"","title":"6. Looping, Conditionals, Switches, &amp; Defers"},{"location":"#for","text":"package main import \"fmt\" func main () { var z float64 for i := 0 ; i < 10 ; i ++ { z = i * i fmt . Println ( z ) } } In Go, we only have a for loop. For loops are broken down into 3 parts: The init statement which is executed before the first iteration (i.e. i := 0 ) The condition statement which is evaluated before each iteration (i.e. i < 10 ) The post statement which is executed at the end of each iteration (i.e. i++ ) Init and post statements on a loop are optional, i.e. package main import \"fmt\" func main () { i := 0 for i < 10 ; { fmt . Println ( i ) i ++ } } The infinite loop package main import \"fmt\" func main () { i := 0 for { i ++ fmt . Println ( i ) } // run until the end of time (or sooner perhaps) }","title":"For"},{"location":"#if","text":"package main import \"fmt\" func main () { x := 13 if x > 11 { fmt . Println ( \"x is greater than 11\" ) } else { fmt . Println ( \"x is not greater than 11\" ) } } The short if package main import ( \"fmt\" \"strings\" ) func main () { greeting := \"Howdy gophers!\" if greeting := \"Howdy\" ; strings . Contains ( greeting , \"ow\" ) { fmt . Println ( greeting ) } }","title":"If"},{"location":"#switch","text":"package main import ( \"fmt\" \"runtime\" ) func main () { switch os := runtime . GOOS ; os { case \"darwin\" : fmt . Println ( \"Reasonable\" ) case \"linux\" : fmt . Println ( \"The superior OS\" ) default : fmt . Println ( \"I want better for you\" ) } } Tip Switch with no condition is the same as switch true which can be useful for long if-else chains.","title":"Switch"},{"location":"#defer","text":"package main import ( \"fmt\" \"os\" ) func main () { out , _ := os . Create ( \"importantData.txt\" ) defer out . Close () // close file executed after main return out . Write ([] byte ( \"867-5309\" )) } Note Deffered functions are pushed onto a stack and executed in last-in-first-out order.","title":"Defer"},{"location":"#7-pointers","text":"package main import \"fmt\" func main () { var i * int // pointer j := 11 i = & j // generate pointer to operand fmt . Printf ( \"address, %v\\n\" , i ) fmt . Printf ( \"value, %v\\n\" , * i ) }","title":"7. Pointers"},{"location":"#8-structs","text":"package main import \"fmt\" type Coordinate struct { X , Y , Z int } func main () { origin := Coordinate { 0 , 0 , 0 } fmt . Println ( origin ) fmt . Printf ( \"x: \\n\" , origin . X ) }","title":"8. Structs"},{"location":"#9-arrays","text":"package main import \"fmt\" func main () { a := [ 5 ] int { 0 , 1 , 2 , 3 , 4 } fmt . Println ( a [ 0 ], a [ 1 ]) fmt . Println ( a [ 2 :]) } Note Arrays are of fixed size!","title":"9. Arrays"},{"location":"#10-slices","text":"package main import \"fmt\" func main () { a := [ 5 ] int { 0 , 1 , 2 , 3 , 4 } var s [] int = a [ 0 : 2 ] fmt . Printf ( \"s: %v, len: %d, cap: %d\\n\" , s , len ( s ), cap ( s )) } Note A slice has a length and capacity. Length is the number of elements it contains, while the capacity is the number of elements in the underlying array. Creating a slice with make package main import \"fmt\" func main () { s := make ([] int , 5 ) // allocate a zeroed array w/ len(s)=10 c := make ([] int , 5 , 10 ) // allocate a zeroed array w/ len(c)=5, cap(c)=10 fmt . Printf ( \"len: %d, cap: %d\\n\" , s , len ( s ), cap ( s )) fmt . Printf ( \"len: %d, cap: %d\\n\" , s , len ( c ), cap ( c )) } Appending to a slice","title":"10. Slices"}]}